name: Deploy Dev to Test - Fetch Raw Configs

on:
  push:
    branches:
      - dev # Trigger when changes are pushed to the 'dev' branch
  workflow_dispatch: # Allows manual triggering from the GitHub UI
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'test'
        type: choice
        options:
          - test

env:
  API_BASE_URL: 'https://emeaps-poc.saviyntcloud.com' # Your actual API base URL
  CONFIG_FILE_PATH: 'config/configdev-to-test-sync.json' # Path to your configuration list file
  OUTPUT_DIR: 'fetched_configs' # Base directory to save all fetched JSON files

jobs:
  prepare_test_deployment:
    runs-on: ubuntu-latest
    environment:
      name: dev_env # This links to a GitHub Environment for secrets/protection rules
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install JQ (for JSON parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch Access Token
        id: get_token
        run: |
          TOKEN_RESPONSE=$(curl -s -X POST \
            "${{ env.API_BASE_URL }}/ECMv6/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{
                  "username": "${{ secrets.API_USERNAME }}",
                  "password": "${{ secrets.API_PASSWORD }}"
                }')
          
          if [ "$(echo "$TOKEN_RESPONSE" | jq -r '.accessToken')" == "null" ]; then
            echo "Error: Failed to fetch access token."
            echo "$TOKEN_RESPONSE"
            exit 1
          fi

          ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.accessToken')
          echo "AccessToken::$ACCESS_TOKEN"
          echo "accessToken=$ACCESS_TOKEN" >> "$GITHUB_OUTPUT"
        env:
          API_USERNAME: ${{ secrets.API_USERNAME }}
          API_PASSWORD: ${{ secrets.API_PASSWORD }}

      - name: Read Configuration List File
        id: read_config_list
        run: |
          if [ ! -f "${{ env.CONFIG_FILE_PATH }}" ]; then
            echo "Error: Configuration file not found at ${{ env.CONFIG_FILE_PATH }}"
            exit 1
          fi
          
          # Read all arrays into distinct variables for iteration
          # Using -r to get raw strings without quotes, and -c to ensure compact output for storing in variables
          SECURITY_SYSTEMS=$(jq -r '.security_systems_to_sync[]' "${{ env.CONFIG_FILE_PATH }}")
          CONNECTIONS=$(jq -r '.connections_to_sync[]' "${{ env.CONFIG_FILE_PATH }}")
          ENDPOINTS=$(jq -r '.endpoints_to_sync[]' "${{ env.CONFIG_FILE_PATH }}")

          # We still output these for potential debugging or future use, 
          # though they are mostly consumed directly in the next step.
          echo "security_systems_to_sync_list=$SECURITY_SYSTEMS" >> "$GITHUB_OUTPUT"
          echo "connections_to_sync_list=$CONNECTIONS" >> "$GITHUB_OUTPUT"
          echo "endpoints_to_sync_list=$ENDPOINTS" >> "$GITHUB_OUTPUT"

      - name: Fetch and Save Individual Dev Configurations
        id: get_and_save_individual_dev_configs
        run: |
          ACCESS_TOKEN="${{ steps.get_token.outputs.accessToken }}"
          AUTH_HEADER="Authorization: Bearer $ACCESS_TOKEN"
          CONTENT_TYPE="Content-Type: application/json"

          # Create base output directory
          mkdir -p ${{ env.OUTPUT_DIR }}
          mkdir -p ${{ env.OUTPUT_DIR }}/security_systems
          mkdir -p ${{ env.OUTPUT_DIR }}/connections
          mkdir -p ${{ env.OUTPUT_DIR }}/endpoints

          # Fetch Security Systems
          echo "Fetching and saving Dev Security Systems..."
          IFS=$'\n' # Set Internal Field Separator to newline for iterating over input
          for SYS_ID in ${{ steps.read_config_list.outputs.security_systems_to_sync_list }}; do
            echo "  Fetching security system: $SYS_ID"
            SYS_DETAILS=$(curl -s -X GET \
              "${{ env.API_BASE_URL }}/ECM/api/v5/getSecuritySystems?systemname=$SYS_ID" \
              -H "$AUTH_HEADER" \
              -H "$CONTENT_TYPE")
            
            if [ -z "$SYS_DETAILS" ] || echo "$SYS_DETAILS" | jq -e 'has("error")' >/dev/null; then
                echo "Warning: Could not fetch details for security system '$SYS_ID'. Response: $SYS_DETAILS"
                exit 1 # Fail if a critical config is not found
            else
                echo "$SYS_DETAILS" > "${{ env.OUTPUT_DIR }}/security_systems/${SYS_ID}.json"
                echo "Saved ${{ env.OUTPUT_DIR }}/security_systems/${SYS_ID}.json"
            fi
          done

          # Fetch Connections (POST with JSON body)
          echo "Fetching and saving Dev Connections..."
          for CONN_ID in ${{ steps.read_config_list.outputs.connections_to_sync_list }}; do
            echo "  Fetching connection: $CONN_ID"
            POST_DATA="{\"connectionname\": \"$CONN_ID\"}"
            
            CONN_DETAILS=$(curl -s -X POST \
              "${{ env.API_BASE_URL }}/ECM/api/v5/getConnectionDetails" \
              -H "$AUTH_HEADER" \
              -H "$CONTENT_TYPE" \
              -d "$POST_DATA")
            
            if [ -z "$CONN_DETAILS" ] || echo "$CONN_DETAILS" | jq -e 'has("error")' >/dev/null; then
                echo "Warning: Could not fetch details for connection '$CONN_ID'. Response: $CONN_DETAILS"
                exit 1
            else
                echo "$CONN_DETAILS" > "${{ env.OUTPUT_DIR }}/connections/${CONN_ID}.json"
                echo "Saved ${{ env.OUTPUT_DIR }}/connections/${CONN_ID}.json"
            fi
          done

          # Fetch Endpoints (POST with JSON body)
          echo "Fetching and saving Dev Endpoints..."
          for ENDP_ID in ${{ steps.read_config_list.outputs.endpoints_to_sync_list }}; do
            echo "  Fetching endpoint: $ENDP_ID"
            POST_DATA="{ \"filterCriteria1\": { \"endpointname\": \"$ENDP_ID\" } }"
            
            ENDP_DETAILS=$(curl -s -X POST \
              "${{ env.API_BASE_URL }}/ECM/api/v5/getEndpoints" \
              -H "$AUTH_HEADER" \
              -H "$CONTENT_TYPE" \
              -d "$POST_DATA")
            
            if [ -z "$ENDP_DETAILS" ] || echo "$ENDP_DETAILS" | jq -e 'has("error")' >/dev/null; then
                echo "Warning: Could not fetch details for endpoint '$ENDP_ID'. Response: $ENDP_DETAILS"
                exit 1
            else
                echo "$ENDP_DETAILS" > "${{ env.OUTPUT_DIR }}/endpoints/${ENDP_ID}.json"
                echo "Saved ${{ env.OUTPUT_DIR }}/endpoints/${ENDP_ID}.json"
            fi
          done
          
          unset IFS # Restore IFS

          # No need to output aggregated JSON variables as they are not used downstream for file saving

      - name: Upload Fetched Configurations as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: dev-configurations-raw
          path: ${{ env.OUTPUT_DIR }}/ # Upload the entire base directory