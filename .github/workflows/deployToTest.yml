name: Deploy Dev to Test - Fetch & Process Configs

on:
  push:
    branches:
      - main # Trigger when changes are pushed to the 'main' branch
  workflow_dispatch: # Allows manual triggering from the GitHub UI
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'test'
        type: choice
        options:
          - test

env:
  API_BASE_URL: 'https://emeaps-poc.saviyntcloud.com' # Your actual API base URL
  CONFIG_FILE_PATH: 'config/configdev-to-test-sync.json' # Path to your configuration list file
  VALID_ATTRIBUTES_CONFIG_PATH: 'config/config-valid-attributes.json' # Path to your valid attributes file
  RAW_OUTPUT_DIR: 'fetched_configs_raw' # Base directory to save all fetched JSON files
  PROCESSED_OUTPUT_DIR: 'fetched_configs_processed' # Directory for processed JSON files

jobs:
  prepare_test_deployment:
    runs-on: ubuntu-latest
    environment:
      name: dev_env # This links to a GitHub Environment for secrets/protection rules
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install JQ (for JSON parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch Access Token
        id: get_token
        run: |
          TOKEN_RESPONSE=$(curl -s -X POST \
            "${{ env.API_BASE_URL }}/ECMv6/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{
                  "username": "${{ secrets.API_USERNAME }}",
                  "password": "${{ secrets.API_PASSWORD }}"
                }')
          
          if [ "$(echo "$TOKEN_RESPONSE" | jq -r '.accessToken')" == "null" ]; then
            echo "Error: Failed to fetch access token."
            echo "$TOKEN_RESPONSE"
            exit 1
          fi

          ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.accessToken')
          echo "AccessToken::$ACCESS_TOKEN" # For logging, not for direct use in subsequent steps
          echo "accessToken=$ACCESS_TOKEN" >> "$GITHUB_OUTPUT"
        env:
          API_USERNAME: ${{ secrets.API_USERNAME }}
          API_PASSWORD: ${{ secrets.API_PASSWORD }}

      - name: Read Configuration List File
        id: read_config_list
        run: |
          if [ ! -f "${{ env.CONFIG_FILE_PATH }}" ]; then
            echo "Error: Configuration file not found at ${{ env.CONFIG_FILE_PATH }}"
            exit 1
          fi
          
          echo "config file ::${{ env.CONFIG_FILE_PATH }} read successfully"
          # Read all arrays into compact JSON strings for passing as outputs
          SECURITY_SYSTEMS_JSON=$(jq -c '.security_systems_to_sync' "${{ env.CONFIG_FILE_PATH }}")
          CONNECTIONS_JSON=$(jq -c '.connections_to_sync' "${{ env.CONFIG_FILE_PATH }}")
          ENDPOINTS_JSON=$(jq -c '.endpoints_to_sync' "${{ env.CONFIG_FILE_PATH }}")

          # Output these as JSON strings
          echo "security_systems_to_sync_json=$SECURITY_SYSTEMS_JSON" >> "$GITHUB_OUTPUT"
          echo "connections_to_sync_json=$CONNECTIONS_JSON" >> "$GITHUB_OUTPUT"
          echo "endpoints_to_sync_json=$ENDPOINTS_JSON" >> "$GITHUB_OUTPUT"

          # Also log them for immediate visibility (optional)
          echo "Security Systems JSON: $SECURITY_SYSTEMS_JSON"
          echo "Connections JSON: $CONNECTIONS_JSON"
          echo "Endpoints JSON: $ENDPOINTS_JSON"

      - name: Fetch and Save Individual Dev Configurations
        id: get_and_save_individual_dev_configs
        run: |
          ACCESS_TOKEN="${{ steps.get_token.outputs.accessToken }}"
          AUTH_HEADER="Authorization: Bearer $ACCESS_TOKEN"
          CONTENT_TYPE="Content-Type: application/json"

          # Create base output directory
          mkdir -p ${{ env.RAW_OUTPUT_DIR }}
          mkdir -p ${{ env.RAW_OUTPUT_DIR }}/security_systems
          mkdir -p ${{ env.RAW_OUTPUT_DIR }}/connections
          mkdir -p ${{ env.RAW_OUTPUT_DIR }}/endpoints

          # Parse JSON outputs back into bash arrays for iteration
          # IMPORTANT: Wrap the GitHub Actions expression in single quotes to ensure jq receives valid JSON
          readarray -t SECURITY_SYSTEMS < <(echo '${{ steps.read_config_list.outputs.security_systems_to_sync_json }}' | jq -r '.[]')
          readarray -t CONNECTIONS < <(echo '${{ steps.read_config_list.outputs.connections_to_sync_json }}' | jq -r '.[]')
          readarray -t ENDPOINTS < <(echo '${{ steps.read_config_list.outputs.endpoints_to_sync_json }}' | jq -r '.[]')

          # Fetch Security Systems
          echo "Fetching and saving Dev Security Systems..."
          for SYS_ID in "${SECURITY_SYSTEMS[@]}"; do # Iterate over the bash array
            echo "  Fetching security system: $SYS_ID"
            SYS_DETAILS=$(curl -s -X GET \
              "${{ env.API_BASE_URL }}/ECM/api/v5/getSecuritySystems?systemname=$SYS_ID" \
              -H "$AUTH_HEADER" \
              -H "$CONTENT_TYPE")
            
            if [ -z "$SYS_DETAILS" ] || echo "$SYS_DETAILS" | jq -e 'has("error")' >/dev/null; then
                echo "Error: Could not fetch details for security system '$SYS_ID'. Response: $SYS_DETAILS"
                exit 1
            else
                echo "$SYS_DETAILS" > "${{ env.RAW_OUTPUT_DIR }}/security_systems/${SYS_ID}.json"
                echo "Saved ${{ env.RAW_OUTPUT_DIR }}/security_systems/${SYS_ID}.json"
            fi
          done

          # Fetch Connections (POST with JSON body)
          echo "Fetching and saving Dev Connections..."
          for CONN_ID in "${CONNECTIONS[@]}"; do # Iterate over the bash array
            echo "  Fetching connection: $CONN_ID"
            POST_DATA="{\"connectionname\": \"$CONN_ID\"}"
            
            CONN_DETAILS=$(curl -s -X POST \
              "${{ env.API_BASE_URL }}/ECM/api/v5/getConnectionDetails" \
              -H "$AUTH_HEADER" \
              -H "$CONTENT_TYPE" \
              -d "$POST_DATA")
            
            if [ -z "$CONN_DETAILS" ] || echo "$CONN_DETAILS" | jq -e 'has("error")' >/dev/null; then
                echo "Error: Could not fetch details for connection '$CONN_ID'. Response: $CONN_DETAILS"
                exit 1
            else
                echo "$CONN_DETAILS" > "${{ env.RAW_OUTPUT_DIR }}/connections/${CONN_ID}.json"
                echo "Saved ${{ env.RAW_OUTPUT_DIR }}/connections/${CONN_ID}.json"
            fi
          done

          # Fetch Endpoints (POST with JSON body)
          echo "Fetching and saving Dev Endpoints..."
          for ENDP_ID in "${ENDPOINTS[@]}"; do # Iterate over the bash array
            echo "  Fetching endpoint: $ENDP_ID"
            POST_DATA="{ \"filterCriteria1\": { \"endpointname\": \"$ENDP_ID\" } }"
            
            ENDP_DETAILS=$(curl -s -X POST \
              "${{ env.API_BASE_URL }}/ECM/api/v5/getEndpoints" \
              -H "$AUTH_HEADER" \
              -H "$CONTENT_TYPE" \
              -d "$POST_DATA")
            
            if [ -z "$ENDP_DETAILS" ] || echo "$ENDP_DETAILS" | jq -e 'has("error")' >/dev/null; then
                echo "Error: Could not fetch details for endpoint '$ENDP_ID'. Response: $ENDP_DETAILS"
                exit 1
            else
                echo "$ENDP_DETAILS" > "${{ env.RAW_OUTPUT_DIR }}/endpoints/${ENDP_ID}.json"
                echo "Saved ${{ env.RAW_OUTPUT_DIR }}/endpoints/${ENDP_ID}.json"
            fi
          done

      - name: Upload Fetched Raw Configurations as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: dev-configurations-raw
          path: ${{ env.RAW_OUTPUT_DIR }}/ # Upload the entire base directory

  process_configurations:
    runs-on: ubuntu-latest
    needs: prepare_test_deployment # This job depends on the successful completion of the previous job
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install JQ (for JSON parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Download Raw Configurations Artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-configurations-raw
          path: ${{ env.RAW_OUTPUT_DIR }} # Download to the same path as it was uploaded from

      - name: Read Valid Attributes Configuration File
        id: read_valid_attributes
        run: |
          if [ ! -f "${{ env.VALID_ATTRIBUTES_CONFIG_PATH }}" ]; then
            echo "Error: Valid attributes configuration file not found at ${{ env.VALID_ATTRIBUTES_CONFIG_PATH }}"
            exit 1
          fi
          # Read the entire config-valid-attributes.json and escape it for output
          VALID_ATTRIBUTES_CONFIG=$(jq -sRr @json "${{ env.VALID_ATTRIBUTES_CONFIG_PATH }}")
          echo "valid_attributes_config=$VALID_ATTRIBUTES_CONFIG" >> "$GITHUB_OUTPUT"

      - name: Process and Save Configurations
        run: |
          # Unescape the JSON string before using it with jq
          VALID_ATTRIBUTES_CONFIG=$(echo '${{ steps.read_valid_attributes.outputs.valid_attributes_config }}' | jq -r '.')
          PROCESSED_DIR="${{ env.PROCESSED_OUTPUT_DIR }}"
          RAW_DIR="${{ env.RAW_OUTPUT_DIR }}"

          mkdir -p "$PROCESSED_DIR"
          mkdir -p "$PROCESSED_DIR/security_systems"
          mkdir -p "$PROCESSED_DIR/connections"
          mkdir -p "$PROCESSED_DIR/endpoints"

          # Function to process a single JSON file
          process_file() {
            local type=$1 # e.g., "connection", "securitySystem", "endpoint"
            local file_path=$2
            local id=$(basename "$file_path" .json)
            local config_json="$VALID_ATTRIBUTES_CONFIG" # This is now the unescaped JSON string

            echo "  Processing $type: $id"
            local processed_json=$(cat "$file_path")

            # Apply exclude rules
            local exclude_keys=$(echo "$config_json" | jq -r ".${type}[\"$id\"].exclude[]? // empty")
            if [ -n "$exclude_keys" ]; then
              for key in $exclude_keys; do
                processed_json=$(echo "$processed_json" | jq "del(.$key)")
              done
              echo "    Excluded keys for $type $id: $exclude_keys"
            fi

            # Apply override rules
            local override_map=$(echo "$config_json" | jq -c ".${type}[\"$id\"].override? // {}")
            if [ "$(echo "$override_map" | jq 'length')" -gt 0 ]; then
              # Merge the override map into the processed JSON
              processed_json=$(echo "$processed_json" | jq --argjson overrides "$override_map" '. * $overrides')
              echo "    Applied overrides for $type $id: $override_map"
            fi

            echo "$processed_json" > "$PROCESSED_DIR/${type}s/${id}.json"
            echo "    Saved processed config to $PROCESSED_DIR/${type}s/${id}.json"
          }

          export -f process_file # Export function for find -exec

          # Process Security Systems
          echo "Processing Security Systems..."
          find "$RAW_DIR/security_systems" -name "*.json" -exec bash -c 'process_file "securitySystem" "$0"' {} \;

          # Process Connections
          echo "Processing Connections..."
          find "$RAW_DIR/connections" -name "*.json" -exec bash -c 'process_file "connection" "$0"' {} \;

          # Process Endpoints
          echo "Processing Endpoints..."
          find "$RAW_DIR/endpoints" -name "*.json" -exec bash -c 'process_file "endpoint" "$0"' {} \;

      - name: Upload Processed Configurations as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: dev-configurations-processed
          path: ${{ env.PROCESSED_OUTPUT_DIR }}/ # Upload the entire processed directory
